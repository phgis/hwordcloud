# 此文件用于增加 R代码的权重
#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}
# 此文件用于增加 R代码的权重
#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}
# 此文件用于增加 R代码的权重
#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}
# 此文件用于增加 R代码的权重
#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}
# 此文件用于增加 R代码的权重
#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}
# 此文件用于增加 R代码的权重
#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}
# 此文件用于增加 R代码的权重
#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}
# 此文件用于增加 R代码的权重
#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}
# 此文件用于增加 R代码的权重
#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}
# 此文件用于增加 R代码的权重
#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}


#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Visualization of Bear Market Spread Strategy
#' @description The bear() function generates a graph showing the gains and losses of bear market spread trading strategies using call or put options. The reason why bear market spreads are constructed is to look short on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bear command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of Option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call" to indicate that the strategy is to buy a call option with a high execution price and sell a call option with a low execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a high execution price and sell a put option with a low execution price. The default value is "call".
#' @examples
#' bear(K1 = 40, opt1 = 6, K2 = 60, opt2 = 2)
#' bear(K1 = 50, opt1 = 2, K2 = 60, opt2 = 6, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{bull}}, \code{\link{butterfly}}
#' @export
bear <- function (K1 = 40, opt1 = 6, K2 = 60, opt2 = 2, type = "call"){
  if (K1 >= K2)
    stop("K1 must be smaller than K2")
  x = seq(K1 - K1/4, K2 + K2/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, K1 - x + opt1, opt1)
    y2 = ifelse(x >= K2, x - K2 - opt2, -opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, x - K1 + opt1, opt1)
    y2 = ifelse(x <= K2, K2 - x - opt2, -opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bear spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bear spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Black-Scholes-Merton Option pricing model and calculation of Greek value
#' @description
#' The BSM function can calculate the theoretical price and Greek value of the option according to the relevant parameters of the input option, including Delta, Gamma, Theta, Vega and Rho.
#' @param S Current stock price, default value is 41
#' @param K Execution price of option, default value is 40
#' @param sigma Annual volatility of the underlying stock price with a default value of 0.3
#' @param r Risk-free interest rate, default value 0.08
#' @param T Expiration time, default value is 1
#' @param t Start time, default value is 0, that is, default duration of options is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param type Specifies the type of option, defaulting to call
#' @examples
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0)
#' BSM(S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1, t = 0, dividend = 0,
#'     type = "put")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @export
BSM <- function (S = 41, K = 40, sigma = 0.3, r = 0.08, T = 1,t = 0, dividend = 0, type = "call"){
  d1 <- (log(S/K) + (r - dividend + sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  d2 <- (log(S/K) + (r - dividend - sigma^2/2) * (T-t))/(sigma * sqrt(T-t))
  pd1t <- - (r + sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd2t <- - (r - sigma^2/2 - dividend)/(2*sigma*sqrt(T-t)) + log(S/K)/(2*sigma*(T-t)^1.5)
  pd1sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) + 0.5*sqrt(T-t)
  pd2sigma <- -(log(S/K) + (r-dividend)*(T-t))/(sigma^2*sqrt(T-t)) - 0.5*sqrt(T-t)
  pd1r <- sqrt(T-t)/sigma
  pd2r <- sqrt(T-t)/sigma
  if (type == "call"){
    phid1 <- pnorm(d1)
    price <- S * exp(-dividend * (T-t)) * phid1 - K * exp(-r * (T-t)) * pnorm(d2)
    delta <- phid1
    gamma <- delta/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t - K*(r*exp(-r*(T-t))*pnorm(d2) + exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r - K*(exp(-r*(T-t))*(t-T)*pnorm(d2) + exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    C <- c(price, delta, gamma, theta, vega, rho)
    names(C) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(C)
  }
  else if (type == "put"){
    phimd1 <- pnorm(-d1)
    price <- -S * exp(-dividend * (T-t)) * phimd1 + K * exp(-r * (T-t)) * pnorm(-d2)
    delta <- -phimd1
    phid1 <- 1 - phimd1
    gamma <- phid1/(S * sigma * sqrt(T-t))
    theta <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1t + K*(r*exp(-r*(T-t))*pnorm(-d2) - exp(-r*(T-t))*exp(-d2^2/2)/sqrt(2*pi)*pd2t)
    vega <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1sigma - K*exp(-r*(T-t))*(exp(-d2^2/2)/sqrt(2*pi))*pd2sigma
    rho <- S*(exp(-d1^2/2)/sqrt(2*pi))*pd1r + K*(exp(-r*(T-t))*(t-T)*pnorm(-d2) - exp(-d2^2/2)/sqrt(2*pi)*exp(-r*(T-t))*pd2r)
    P <- c(price, delta, gamma, theta, vega, rho)
    names(P) <- c("price", "delta", "gamma", "theta", "vega", "rho")
    return(P)
  }
}

#' Visualization of Bull Market Spread Strategy
#' @description The bull() function generates a graph showing the profit and loss of bull spread trading strategies using call or put options. The reason why the bull market spreads strategy is constructed is that it is bullish on the market.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, use type = "call", indicating that the strategy is to buy a call option with a low execution price and sell a call option with a high execution price; if it is a put option, use type = "put", indicating that the strategy is to buy a put option with a low execution price and sell a put option with a high execution price. The default value is "call".
#' @examples
#' bull(K1 = 40, opt1 = 5, K2 = 60, opt2 = 3)
#' bull(K1 = 40, opt1 = 3, K2 = 45, opt2 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{butterfly}}
#' @export
bull <- function (K1 = 40, opt1 = 5, K2 = 60, opt2 = 3, type = "call"){
  if (K1 >= K2)
    stop("K1 must small than K2")
  x = seq(K1 - 20, K2 + 20, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y2 = ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y2 = ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2
  plot(x, y, type = "l", ann = FALSE, ylim = c(min(y1, y2), max(y1, y2)), col = 2, lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Bull spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Bull spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff of option with higher strike price"), col = 2:4, lty = 1, cex = 0.75)
  }
}

#' Visualization of Butterfly Spread Strategy
#' @description The butterfly() function generates a graph showing the profit and loss of butterfly spread trading strategies using call or put options. The reason why butterfly spreads are constructed is that the stock price is expected to change only slightly in the future.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run bull command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K1 Execution Price of Option 1
#' @param opt1 Price of option 1
#' @param K2 Execution Price of Option 2
#' @param opt2 Price of Option 2
#' @param K3 Execution Price of Option 3
#' @param opt3 Price of Option 3
#' @param type Specifies whether to use call option or put option to carry bear market spread arbitrage. If it is a call option, type = "call" is used to indicate that the strategy is to buy a call option with low execution price and a call option with high execution price and sell two call options with intermediate execution price at the same time; if it is a put option, type = "put" is used to indicate that the strategy is to buy a put option with low execution price and a put option with high execution price at the same time. Put options with two intermediate execution prices. The default value is "call".
#' @examples
#' butterfly(K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1)
#' butterfly(K1 = 45, opt1 = 1, K2 = 50, opt2 = 3, K3 = 55, opt3 = 5, type = "put")
#' @references
#' OTS package, WangXu <seniorwangxu@sina.com>
#' @seealso
#' \code{\link{bear}}, \code{\link{bull}}
#' @export
butterfly <- function (K1 = 45, opt1 = 5, K2 = 50, opt2 = 3, K3 = 55, opt3 = 1, type = "call"){
  if (((K1 < K2) & (K2 < K3)) != 1)
    stop("K1, K2, K3 must be in the order of small to large")
  x = seq(K1 - K1/4, K3 + K3/4, 0.01)
  if (type == "call") {
    y1 = ifelse(x >= K1, x - K1 - opt1, -opt1)
    y3 = ifelse(x >= K3, x - K3 - opt3, -opt3)
    y2 = 2 * ifelse(x >= K2, K2 - x + opt2, opt2)
  }
  else if (type == "put") {
    y1 = ifelse(x <= K1, K1 - x - opt1, -opt1)
    y3 = ifelse(x <= K3, K3 - x - opt3, -opt3)
    y2 = 2 * ifelse(x <= K2, x - K2 + opt2, opt2)
  }
  y = y1 + y2 + y3
  plot(x, y, type = "l", ann = FALSE, ylim = c(-max(y1, y2, y3), max(y1, y2, y3)), col = 2,lty = 1, lwd = 2)
  lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
  lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
  lines(x, y3, type = "l", col = 5, lty = 1, lwd = 1)
  abline(h = 0, lty = 2)
  if (type == "call"){
    title(main = "Butterfly spread strategy using call options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomleft", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:4, lty = 1, cex = 0.9)
  }
  else if (type == "put"){
    title(main = "Butterfly spread strategy using put options", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from option with lower strike price", "Payoff from option with higher strike price"), col = 2:5, lty = 1, cex = 0.75)
  }
}

#' Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' callbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' callbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dcallbt}}
#' @export
callbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Execution price, default value is 5
#' @param u up ratio, default value if 2
#' @param d down ratio, default value if 1/2
#' @param r Risk-free interest rate, default value is 0.25
#' @param T Option maturity, default value is 3
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dputbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dputbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{putbt}}
#' @export
dputbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' Binary Tree Pricing of Call Options (Discrete Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 4
#' @param K Current stock price, default value is 4 executive price, default value is 5.
#' @param u up ratio.
#' @param d down ratio.
#' @param r Risk-free interest rate, default value is 0.25.
#' @param T Option maturity, default value is 3.
#' @param l The default length of each period in a binary tree is 1, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' dcallbt(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' dcallbt(S = 41, K = 50, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{callbt}}
#' @export
dcallbt <- function(S = 4, K = 5, r = 1/4, u = 2, d = 1/2, T = 3, l = 1)
{
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  p = (1 + r - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (BT[n + 1, ] - K) * ((BT[n + 1, ] - K) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = (1 + r)^(-l) * (p * CT[i + 1, j] + (1 - p) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European call", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}

#' FMFE package
#' @description An option pricing and trading strategy visualization package. It is mainly used in Song Haozhang's financial engineering and mathematics.
#' @section \code{\link{bear}}: Visualization of Bear Market Spread Strategy
#' @section \code{\link{bull}}: Visualization of Bull Market Spread Strategy
#' @section \code{\link{butterfly}}: Visualization of Butterfly Spread Strategy
#' @section \code{\link{BSM}}: BSM Option Pricing Model and Greek Value Calculation
#' @section \code{\link{protective.put}}: Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @section \code{\link{writing.call}}: Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @section \code{\link{callbt}}: Binary Tree Pricing of Call Options (Continuous Compound Interest)
#' @section \code{\link{dcallbt}}: Binary Tree Pricing of Call Options (Discrete Compound Interest, the Simplest Method Introduced in the Financial Random Analysis Book)
#' @section \code{\link{putbt}}: Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @section \code{\link{dputbt}}: Binary Tree Pricing of Put Options (Discrete Compound Interest)
#' @docType package
#' @name FMFE
NULL

#' Visualization of Protection Selling Strategy (Reverse Operation of Protection Selling Strategy)
#' @description The protective.put() function generates a graph showing the profits and losses of both long and short put options and stock portfolios. The reason for the construction of the strategy is to be bullish on the market, but also worried about the future stock price decline. If the future stock price falls, put options can be executed to compensate for the loss. Its reverse operation is short on the market, but also worries about the future stock price rise. If the future stock price rises, the option fee obtained by short put option can compensate for the loss.
#' @note If there is a mutual occlusion problem in the image, you can run the dev. new () command first. If there are still occlusion problems, you can directly run the protective. put command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution Price of Put Options
#' @param opt The Price of Put Options
#' @param S Current stock price, default value is 42
#' @param position It specifies whether to use a positive strategy to protect the right to sell (multi-selling and underlying stocks at the same time), or a reverse strategy to protect the right to sell (short selling and underlying stocks at the same time).
#' @examples
#' protective.put(K = 40, opt = 5, S = 42)
#' protective.put(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{writing.call}}
#' @export
protective.put <- function(K = 40, opt = 5, S = 50, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, K - x - opt, -opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Protective put Strategy", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from long put"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, x - K + opt, opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a protective put", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from short put"), col = 2:4, lty = 1, cex = 0.9)
  }
}

#' Binary Tree Pricing of Put Options (Continuous Compound Interest)
#' @description The function uses a binary tree to price European options, and finally draws a binary tree and the price of return options.
#' @param S Current stock price, default value is 41
#' @param K Execution price, default value is 40
#' @param sigma Volatility of stock price, default value is 0.3
#' @param r Risk-free interest rate, default value is 0.2
#' @param T Option maturity, default value is 1
#' @param dividend Compound dividend rate, default value is 0, that is, no dividend.
#' @param l The default length of each period in a binary tree is 1/3, that is, the default duration of a binary tree is 3 periods.
#' @examples
#' putbt(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' putbt(S = 50, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
#' @references
#' OTS package, WangXu <seniorwangxu@@sina.com>
#' @seealso
#' \code{\link{dputbt}}
#' @export
putbt <- function(S = 41, K = 40, sigma = 0.3, r = 0.2, T = 1, dividend = 0, l = 1/3)
{
  u = exp(sigma*sqrt(l))
  d = exp(-sigma*sqrt(l))
  n = T / l
  BT <- matrix(ncol = n + 1, nrow = n + 1)
  plot(0, 0, axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 2 * n + 2), ylim = c(-n - 1, n + 2))
  for(i in 1:n){
    for(j in 1:i){
      BT[i, j] = S * d^(j - 1) * u^(i - j)
      points(2 * i - 2, i + 1 - 2 * j)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i + 2 - 2 * j, length = 0.1, angle = 10, code = 2)
      arrows(2 * i - 2, i + 1 - 2 * j, 2 * i, i - 2 * j, length = 0.1, angle = 10, code = 2)
      text(2 * i - 2, i + 1 - 2 * j, round(BT[i, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
    }
  }
  for(j in 1:(n+1)){
    BT[n + 1, j] = S * d^(j - 1) * u^(n + 1 - j)
    points(2 * n, n + 2 - 2 * j)
    text(2 * n, n + 2 - 2 * j, round(BT[n + 1, j], 3), col = 2, adj = 0, pos = 3, offset = 0.5, cex = 0.75)
  }
  pstar = (exp((r - dividend) * l) - d)/(u - d)
  CT <- matrix(ncol = n + 1, nrow = n + 1)
  CT[n + 1, ] = (K - BT[n + 1, ]) * ((K - BT[n + 1, ]) >= 0)
  for(j in 1:(n + 1)){
    text(2 * n, n + 2 - 2 * j, round(CT[n + 1, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
  }
  for(i in n:1){
    for(j in 1:i){
      CT[i, j] = exp(-r * l) * (pstar * CT[i + 1, j] + (1 - pstar) * CT[i + 1, j + 1])
      text(2 * i - 2, i + 1 - 2 * j, round(CT[i, j], 3), col = 3, adj = 0, pos = 1, offset = 0.5, cex = 0.75)
    }
  }
  mtext("Binomial tree pricing for European put", side = 1, cex = 1.25)
  return(round(CT[1, 1], 3))
}
putbt()

#' Visualization of the Strategy of Sale of Standby Purchase Rights (Reverse Operation of the Strategy of Sale Standby Purchase Rights)
#' @description The write.call() function generates a graph showing the profits and losses of short call options and long stock portfolios or long call options and short stock portfolios. The reason for the strategy of selling covered call right is that it is bullish on the market, but worries about the future stock price decline. If the future stock price falls, the gains of short call right can be used to compensate for the losses. Its reverse operation is short-sighted on the market, but also worried about the future stock price rise, if the future stock price rises, we can compensate for the loss through the implementation of the right to buy.
#' @note If there is a mutual occlusion problem in the image, you can run the dev.new() command first. If there is still occlusion problem, you can directly run the writing. call command to call out the source code of the function, and eliminate the occlusion problem by modifying the corresponding graphic parameters.
#' @param K Execution price of call option
#' @param S Current stock price, default value is 42
#' @param opt The Price of Call Options
#' @param position Specify whether to use the forward redemption strategy (-C+S) or the reverse protection strategy (+C-S)。
#' @examples
#' writing.call(K = 40, opt = 5, S = 42)
#' writing.call(K = 40, opt = 5, S = 42, position = "short")
#' @references
#' John C.Hull. Options, Futures, and other Derivatives 9ed
#' @seealso
#' \code{\link{protective.put}}
#' @export
writing.call <- function(K = 40, opt = 5, S = 42, position = "long"){
  if (position != "long" & position != "short")
    stop("position must equal long or short")
  x = seq(K - K/2, K + K/2, 0.01)
  if (position == "long"){
    y1 = x - S
    y2 = ifelse(x <= K, opt, K - x + opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "Writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("bottomright", c("Portfolio payoff", "Payoff from long stock", "Payoff from short call"), col = 2:4, lty = 1, cex = 0.9)
  }
  if (position == "short"){
    y1 = S - x
    y2 = ifelse(x <= K, -opt, x - K - opt)
    y = y1 + y2
    plot(x, y, type = "l", ann = FALSE, ylim = c(1.5*min(min(y1, y2), y), 1.5*max(max(y1, y2), y)), col = 2, lty = 1, lwd = 2)
    lines(x, y1, type = "l", col = 3, lty = 1, lwd = 1)
    lines(x, y2, type = "l", col = 4, lty = 1, lwd = 1)
    abline(h = 0, lty = 2)
    title(main = "The reverse of a writing a covered call", xlab = "Stock price", ylab = "Payoff", cex.lab = 1)
    legend("topright", c("Portfolio payoff", "Payoff from short stock", "Payoff from long call"), col = 2:4, lty = 1, cex = 0.9)
  }
}
